webpackJsonp([6],{41:function(e,n,s){var t=s(0)(null,s(90),null,null);e.exports=t.exports},90:function(e,n){e.exports={render:function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("div",[s("div",{staticClass:"title"},[e._v("\n      vue之组件通信\n    ")]),e._v(" "),s("div",{staticClass:"tag"},[e._v("\n      vue\n    ")]),e._v(" "),s("summary",[e._v("\n      在vue业务开发中，我们经常需要将一个数据反正不同组件中使用，但是由于vue的组件作用域是孤立的，所以如何在各个组件间通信，就是我们不得不解决的一个问题。在vue中，组件间的通信主要分父子组件通信和非父子组件通信，下面我们详细来说。\n    ")]),e._v(" "),s("h3",[e._v("1. 父子组件--父传子")]),e._v(" "),e._m(0),e._v(" "),s("pre",[e._v("\n        // parent.vue\n        <\\child message=\"this is a message\"><\\/child>\n\n        // child.vue\n        <\\div>\n            {\\{message}}\n        <\\/div>\n\n        props: ['message']\n    ")]),e._v(" "),s("p",[e._v("如果我们需要动态传递一个数据时，我们需要在子组件上使用v-bind")]),e._v(" "),s("pre",[e._v("\n        // parent.vue\n        <\\child :message=\"data\"><\\/child>\n\n        data() {\n            return {\n                data: 'this is a message'\n            }\n        }\n\n        // child.vue\n        <\\div>\n            {\\{message}}\n        <\\/div>\n\n        props: ['message']\n    ")]),e._v(" "),s("h4",[e._v("camelCase及kabab-case")]),e._v(" "),s("p",[e._v("HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名：")]),e._v(" "),s("pre",[e._v("\n        Vue.component('child', {\n            // camelCase in JavaScript\n            props: ['myMessage'],\n            template: '"),s("span",[e._v(e._s(e.myMessage))]),e._v("'\n        })\n\n        "),e._v('\n        <\\child my-message="hello!"><\\/child>\n    ')]),e._v(" "),e._m(1),e._v(" "),s("p",[e._v("如果我们希望父组件传递过来的值仅作为一个子组件的初始值的时候，我们可以在子组件中用data或者computed重新接收一遍")]),e._v(" "),s("pre",[e._v("\n        props: ['message'],\n        data() {\n            return {\n                myMessage: this.message // 这个时候你可以任意修改myMessage\n            }\n        }\n        // 或者直接作为计算属性\n        props: ['message'],\n        computed: {\n            myMessage: function() {\n                return this.message.toLowerCase()\n            }\n        }\n    ")]),e._v(" "),s("p",[e._v("如果我们想传递的不是一个数据，而是一个方法的时候，我们可以这么做")]),e._v(" "),s("pre",[e._v("\n        // parent.vue\n        <\\child :myChild=\"myParent\"><\\/child>\n\n        methods: {\n            myParent: function() {\n                console.log('parent')\n            }\n        }\n\n        // child.vue\n        <\\div @click=\"myChild\">here is child.vue<\\/div>\n\n        props: ['myChild']\n    ")]),e._v(" "),s("h3",[e._v("2. 父子组件--子传父")]),e._v(" "),s("p",[e._v("相对于父传子来说，可能子传父会相对复杂一些。在父传子中，我们用了一个props属性，可以让子组件接受父组件想传递的值。但是当在子传父的时候，我们需要使用自定义事件")]),e._v(" "),s("p",[e._v("vue首先定义了两个东西: $on、$emit。使用 $on(eventName) 监听事件，使用 $emit(eventName) 触发事件。")]),e._v(" "),s("pre",[e._v("\n        // 我们需要将child.vue中的message输出到parent.vue中打印\n\n        // parent.vue\n        <\\child v-on:myChild=\"myParent\"><\\/child>\n\n        methods: {\n            myParent: function(message) {\n                console.log(message)\n            }\n        }\n\n        // child.vue\n        <\\div @click=\"childEvent\"><\\/div>\n        data() {\n            return {\n                message: 'this is a message'\n            }\n        }\n        methods: {\n            childEvent() {\n                this.$emit('myChild', this.message)\n            }\n        }\n    ")]),e._v(" "),s("h3",[e._v("3. 非父子组件通信")]),e._v(" "),s("p",[e._v("非父子组件间的通信很多时候也被叫做兄弟组件间通信，vue定义了一个event bus的东西，其实就是个发布订阅模式")]),e._v(" "),s("pre",[e._v("\n        // parent.vue\n        <\\div>\n            <\\child1><\\/child1>\n            <\\child2><\\/child2>\n        <\\/div>\n    ")]),e._v(" "),s("p",[e._v("现在我们有两个子组件，分别是child1和child2，如果我想要在child2里面获取child1的数据该怎么做呢？")]),e._v(" "),e._m(2),e._v(" "),s("pre",[e._v("\n        <\\script>\n            import Vue from 'vue'\n            export default new Vue()\n        <\\/script>\n    ")]),e._v(" "),e._m(3),e._v(" "),s("pre",[e._v("\n        <\\div @click=\"toChild2\"><\\/div> <--通过toChild2触发整个过程--\x3e\n\n        import bus from 'xxx/bus.vue' // 先引入bus\n\n        components: { // 然后将bus注册为组件\n            bus\n        },\n        data() {\n            return {\n                message: 'this is a message' // 需要传递的数据\n            }\n        },\n        methods: {\n            toChild2() {\n                bus.$emit('passMessage', this.message) // $emit了一个叫做passMessage的方法，并为其传递了一个this.message的参数\n            }\n        }\n    ")]),e._v(" "),e._m(4),e._v(" "),s("pre",[e._v("\n        // child2.vue\n        import bus from 'xxx/bus.vue'\n\n        components: {\n            bus\n        },\n        create() {\n            bus.$on('passMessage', (data) => { // 这里在实际应用中要注意this的指向\n                console.log(data) // 输出 this is a message\n            })\n        }\n    ")]),e._v(" "),e._m(5),e._v(" "),s("p",[e._v("关于vuex的使用，下次再说")])])},staticRenderFns:[function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("p",[e._v("当我们在一个组件中引入了另外一个组件时，就很容易的形成了父子组件的嵌套关系。现在如果我们在父组件中有一个message，我们想把这个message告诉子组件，让其也可以对其访问，我们可以用 "),s("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components.html#Prop"}},[e._v("props")]),e._v(" 来实现")])},function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("p",[s("span",{staticClass:"warnning"},[e._v("注意:")]),e._v(" 任何时候，我们都不应该在子组件中修改props")])},function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("p",[s("strong",[e._v("1.")]),e._v("新建一个bus.vue，里面就这样写")])},function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("p",[s("strong",[e._v("2.")]),e._v("我们需要把child1里面的数据先传给bus.vue")])},function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("p",[s("strong",[e._v("3. ")]),e._v("最后我们需要在child2.vue中去调取bus中的passMessage方法就可以了")])},function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("p",[e._v("用event bus确实能实现不同组件间的通信，但是当项目组件过于庞大，组件之间的通信就会变得过重难以管理。所以官方推荐，当项目变大的时候，我们应该选择使用 "),s("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/"}},[e._v("vuex")]),e._v(" ，毕竟veux设计出来的初衷就是为何更好的管理组件的状态")])}]}}});
//# sourceMappingURL=6.b073b33807396da1faad.js.map