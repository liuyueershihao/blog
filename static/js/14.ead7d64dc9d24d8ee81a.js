webpackJsonp([14],{32:function(n,r,t){var e=t(0)(null,t(80),null,null);n.exports=e.exports},80:function(n,r){n.exports={render:function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},staticRenderFns:[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",[t("div",{staticClass:"title"},[n._v("前端面试(一)")]),n._v(" "),t("div",{staticClass:"tag"},[n._v("其他")]),n._v(" "),t("summary",[n._v("最近准备去面试，所以总结一下常见的面试题")]),n._v(" "),t("h3",[n._v("1. 闭包")]),n._v(" "),t("p",[t("strong",[n._v("1.1 什么是闭包?")])]),n._v(" "),t("p",[n._v("闭包就是一个通过返回一个函数的形式来私有调用函数内部变量的函数。")]),n._v(" "),t("p",[t("strong",[n._v("1.2 闭包特性")])]),n._v(" "),t("p",[n._v("(1) 外部读取内部变量")]),n._v(" "),t("p",[n._v("(2) 让变量一直保存在内存中")]),n._v(" "),t("p",[n._v("第一个就是闭包的基本概念，没啥好说的。至于第二个，简单来说，普通函数在执行完后会被js垃圾回收机制回收归堆。但是对于闭包，在外部函数执行完后，还存在着内部函数对外部函数变量的引用，这在js中是无法被垃圾回收机制回收的。")]),n._v(" "),t("p",[n._v("所以闭包也存在了一个很明显的缺点：就是容易导致内存泄露。当我们在应用闭包时需要谨慎。当然也有一些可以解决内存泄露的办法，这里不多解释。")]),n._v(" "),t("pre",[n._v('\r\n        var name = "The Window";\r\n    　　var object = {\r\n    　　　　name : "My Object",\r\n    　　　　getNameFunc : function(){\r\n    　　　　　　return function(){\r\n    　　　　　　　　return this.name;\r\n    　　　　　　};\r\n    　　　　}\r\n    　　};\r\n    　　alert(object.getNameFunc()()); // The Window\r\n\r\n        var name = "The Window";\r\n    　　var object = {\r\n    　　　　name : "My Object",\r\n    　　　　getNameFunc : function(){\r\n    　　　　　　var that = this;\r\n    　　　　　　return function(){\r\n    　　　　　　　　return that.name;\r\n    　　　　　　};\r\n    　　　　}\r\n    　　};\r\n    　　alert(object.getNameFunc()()); // MY Object\r\n    ')]),n._v(" "),t("h3",[n._v("2. AJAX原理")]),n._v(" "),t("h3",[n._v("3. get和post区别")]),n._v(" "),t("h3",[n._v("4. 数组去重")]),n._v(" "),t("pre",[n._v("\r\n    function noRepeatArray(arr) {\r\n        var obj = {}, newArr = []\r\n        for(var i = 0, len = arr.length; i < len; i++) {\r\n            if (!obj[arr[i]]){\r\n                obj[arr[i]] = -1\r\n                newArr.push(arr[i])\r\n            }\r\n        }\r\n        return newArr\r\n    }\r\n    ")]),n._v(" "),t("h3",[n._v("5. 快排算法")]),n._v(" "),t("pre",[n._v("\r\n    function quickSort(arr) {\r\n        if (arr.length <= 1) {\r\n            return arr\r\n        }\r\n        var left = [], right = [];\r\n        var flag_index = Math.floor(arr.length / 2)\r\n        var flag = arr.splice(flag_index, 1)[0]\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] > flag) {\r\n                right.push(arr[i])\r\n            } else {\r\n                left.push(arr[i])\r\n            }\r\n        }\r\n        return quickSort(left).concat([flag], quickSort(right))\r\n    }\r\n    ")]),n._v(" "),t("h3",[n._v("6. lazyman实现")]),n._v(" "),t("p",[n._v("需要实现下面的功能:")]),n._v(" "),t("pre",[n._v("\r\n    LazyMan('Hank')\r\n    // Hi, This is Hank\r\n    LazyMan('Hank').sleep(10).eat('dinner')\r\n    // Hi, This is Hank\r\n    // 等待10s...\r\n    // Wake up after 10s\r\n    // eat dinner\r\n    LazyMan('Hank').eat('dinner').eat(supper)\r\n    // Hi, This is Hank\r\n    // eat dinner\r\n    // eat supper\r\n    LazyMan(\"Hank\").sleepFirst(5).eat(\"supper\")\r\n    // 等待5s...\r\n    // Wake up after 5\r\n    // Hi This is Hank!\r\n    // Eat supper\r\n    ")]),n._v(" "),t("p",[n._v("实现:")]),n._v(" "),t("pre",[n._v("\r\n    var _LazyMan = function(name) {\r\n        this.tasks = []\r\n        var self = this\r\n        var fn = function() {\r\n            console.log('Hi, This is ' + name)\r\n            self.next()\r\n        }\r\n        this.tasks.push(fn)\r\n        setTimeout(function() {\r\n            self.next()\r\n        }, 0)\r\n    }\r\n    _LazyMan.prototype.next = _LazyMan.prototype.next || function() {\r\n        var fn = this.tasks.shift()\r\n        fn && fn()\r\n    }\r\n    _LazyMan.prototype.eat = _LazyMan.prototype.eat || function(str) {\r\n        var self = this\r\n        var fn = function() {\r\n            setTimeout(function() {\r\n                console.log('eat ' + str)\r\n                self.next()\r\n            }, 0)\r\n        }\r\n        this.tasks.push(fn)\r\n        return this\r\n    }\r\n    _LazyMan.prototype.sleep = _LazyMan.prototype.sleep || function(time) {\r\n        var self = this\r\n        var fn = function() {\r\n            setTimeout(function() {\r\n                console.log('wake up after ' + time + 's...')\r\n                self.next()\r\n            }, time * 1000)\r\n        }\r\n        this.tasks.push(fn)\r\n        return this\r\n    }\r\n    _LazyMan.prototype.sleepFirst = _LazyMan.prototype.sleepFirst || function(time) {\r\n        var self = this\r\n        var fn = function() {\r\n            setTimeout(function() {\r\n                console.log('wake up after ' + time +'s...')\r\n                self.next()\r\n            }, time * 1000)\r\n        }\r\n        this.tasks.unshift(fn)\r\n        return this\r\n    }\r\n    var LazyMan = function(name) {\r\n        return new _LazyMan(name)\r\n    }\r\n    ")])])}]}}});
//# sourceMappingURL=14.ead7d64dc9d24d8ee81a.js.map