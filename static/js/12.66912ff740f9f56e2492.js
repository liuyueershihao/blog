webpackJsonp([12],{34:function(n,e,r){var v=r(0)(null,r(75),null,null);n.exports=v.exports},75:function(n,e){n.exports={render:function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},staticRenderFns:[function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("div",[r("div",{staticClass:"title"},[n._v("关于构造函数的一些细节")]),n._v(" "),r("div",{staticClass:"tag"},[n._v("javascript")]),n._v(" "),r("summary",[n._v("相信大家对javascript中的构造函数都应该是耳熟能详了，在这里我将构造函数重新拎出来讲主要是讲一点大家平时不太常见的一个问题：如果构造函数带参数了会该怎么办")]),n._v(" "),r("h3",[n._v("new")]),n._v(" "),r("p",[n._v("正常用 new 操作符调用构造函数的过程：")]),n._v(" "),r("p",[r("strong",[n._v("1. ")]),n._v(" 创建一个新对象（应当注意的是：此时该对象并未被暴露，也更谈不上被谁引用了）")]),n._v(" "),r("p",[r("strong",[n._v("2. ")]),n._v(" 将构造函数的作用域赋给新对象（因此 "),r("code",[n._v("this")]),n._v(" 指向了这个新对象）")]),n._v(" "),r("p",[r("strong",[n._v("3. ")]),n._v(" 执行构造函数中的代码（为这个新对象添加属性）")]),n._v(" "),r("p",[r("strong",[n._v("4. ")]),n._v(" 返回新对象（此时对象被暴露，可以被外界引用）")]),n._v(" "),r("p",[n._v("举个栗子:")]),n._v(" "),r("pre",[n._v("\r\n        function Person(name, age, job) {\r\n            this.name = name\r\n            this.age = age\r\n            this.job = job\r\n        }\r\n        var person = new Person('Allen', 18, 'student')\r\n\r\n        person.name // Allen\r\n        person.age // 18\r\n        person.job // student\r\n    ")]),n._v(" "),r("p",[n._v("以上是一个比较常见的正常栗子，但是如果我稍微变下，变成这样：")]),n._v(" "),r("pre",[n._v("\r\n        function Person(name, age, job) {\r\n            this.name = name\r\n            this.age = age\r\n            this.job = job\r\n            return this\r\n        }\r\n        var person = new Person('Allen', 18, 'student')\r\n    ")]),n._v(" "),r("p",[n._v("这里我在构造函数的内部加了一个返回值，要知道，我们一般碰到的构造函数都是不带返回值的。这时候再输出 "),r("code",[n._v("person.name")]),n._v("/"),r("code",[n._v("person.age")]),n._v("/"),r("code",[n._v("person.job")]),n._v(" 会是什么呢？由于这边我们返回值的特殊性，我们会发现，最后的结果还是一样。")]),n._v(" "),r("pre",[n._v("\r\n        function Person(name, age, job) {\r\n            this.name = name\r\n            this.age = age\r\n            this.job = job\r\n            return 1 // 如果我不想返回 this 我就想返回一个乱七八糟的东西，这时候会发生什么呢\r\n        }\r\n        var person = new Person('Allen', 18, 'student')\r\n    ")]),n._v(" "),r("p",[n._v("经过测试发现，但我返回的值是 "),r("code",[n._v("number")]),n._v("/"),r("code",[n._v("string")]),n._v("/"),r("code",[n._v("boolean")]),n._v("/"),r("code",[n._v("null")]),n._v("/"),r("code",[n._v("undefined")]),n._v(" 等值的时候，结果是不会变的")]),n._v(" "),r("p",[n._v("但是但我返回 "),r("code",[n._v("object")]),n._v("/"),r("code",[n._v("function")]),n._v("/"),r("code",[n._v("array")]),n._v("/"),r("code",[n._v("date")]),n._v(" 等引用类型的时候，"),r("code",[n._v("person")]),n._v("的结果就成为了该返回值，而其所有的属性和方法都没有在被实例对象所继承，而此时：")]),n._v(" "),r("pre",[n._v("\r\n        function Person(name, age, job) {\r\n            this.name = name\r\n            this.age = age\r\n            this.job = job\r\n            return {}\r\n        }\r\n        var person = new Person('Allen', 18, 'student')\r\n        console.log(person.constructor == Person) // false\r\n    ")]),n._v(" "),r("p",[n._v("就是说此时"),r("code",[n._v("person")]),n._v("就不在是"),r("code",[n._v("Person")]),n._v("的实例对象了。这个说明了构造函数是不能拥有引用类型的返回值，一旦有这种类型的返回值就不能再成为一个构造函数了（"),r("code",[n._v("this")]),n._v("除外，估计构造函数内部本身就是返回的是"),r("code",[n._v("this")]),n._v("对象）")])])}]}}});
//# sourceMappingURL=12.66912ff740f9f56e2492.js.map