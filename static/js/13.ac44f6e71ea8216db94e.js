webpackJsonp([13],{33:function(e,n,r){var t=r(0)(null,r(76),null,null);e.exports=t.exports},76:function(e,n){e.exports={render:function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},staticRenderFns:[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",[r("div",{staticClass:"title"},[e._v("前端面试(二)")]),e._v(" "),r("div",{staticClass:"tag"},[e._v("javascript")]),e._v(" "),r("summary",[e._v("之前面试看到这么一个题目，当时脑子没转过弯来，后来在网上参考了一些东西，然后写下来")]),e._v(" "),r("h3",[e._v("题目")]),e._v(" "),r("pre",[e._v("\r\n        function Foo() {\r\n            getName = function() {\r\n                alert(1)\r\n            }\r\n            return this\r\n        }\r\n        Foo.getName = function() {\r\n            alert(2)\r\n        }\r\n        Foo.prototype.getName = function() {\r\n            alert(3)\r\n        }\r\n        var getName = function() {\r\n            alert(4)\r\n        }\r\n        function getName() {\r\n            alert(5)\r\n        }\r\n        // 然后问一下输出什么\r\n        Foo.getName()\r\n        getName()\r\n        Foo().getName()\r\n        getName()\r\n        new Foo.getName()\r\n        new Foo().getName()\r\n        new new Foo().getName()\r\n        // 答案是: 2 4 1 1 2 3 3\r\n    ")]),e._v(" "),r("p",[e._v("为什么是这样呢？我们一个个来看")]),e._v(" "),r("p",[e._v("首先，他用函数表达式定义了一个Foo的函数，函数在刚被定义的时候是不执行的；之后为Foo创建了一个getName的方法；接着在Foo的原型上创建了一个getName的方法；最后，在全局（window）中分别用函数表达式和函数声明式创建了两个getName的函数，题目看到这里首先就出现了一个问题：在window下明显不可能同时出现两个getName函数，那势必有一个函数是会被覆盖掉的，问题是哪一个会被覆盖呢？")]),e._v(" "),r("h3",[e._v("变量声明提前")]),e._v(" "),r("p",[e._v("我们都知道js存在一个声明提前的问题，比如这样的一个简单问题：")]),e._v(" "),r("pre",[e._v("\r\n        console.log(x)// 报错Uncaught ReferenceError: x is not defined\r\n    ")]),e._v(" "),r("p",[e._v("但是这样又不一样了")]),e._v(" "),r("pre",[e._v("\r\n        console.log(x) // undefined\r\n        var x = 1\r\n    ")]),e._v(" "),r("p",[e._v("他会输出undefined。因为上面的方法相当于这样:")]),e._v(" "),r("pre",[e._v("\r\n        var x;\r\n        console.log(x)\r\n        x = 1\r\n    ")]),e._v(" "),r("p",[e._v("这就是声明提前。从这里可以看出，用关键字var声明的变量会提前，但是其不会赋值，也就是说他会把声明提到前面，而把赋值留在原地。但是，你用函数表达式声明一个函数的时候，他也会提前，但是他的提前就不是这么提前了，他会将整个函数体都提到前面来，所以上面最后两个getName相当于这样：")]),e._v(" "),r("pre",[e._v("\r\n        var getName; // 将变量提前\r\n        function getName() {alert(5)} // 将整个函数体提前\r\n        getName = function() {alert(4)}\r\n    ")]),e._v(" "),r("p",[e._v("所以，最后两个只会保留alert(4)函数。这样一理的话原题目就变成了")]),e._v(" "),r("pre",[e._v("\r\n        function Foo() {\r\n            getName = function() {\r\n                alert(1)\r\n            }\r\n            return this\r\n        }\r\n        Foo.getName = function() {\r\n            alert(2)\r\n        }\r\n        Foo.prototype.getName = function() {\r\n            alert(3)\r\n        }\r\n        var getName;\r\n        getName = function() {\r\n            alert(4)\r\n        }\r\n    ")]),e._v(" "),r("p",[e._v("然后我们再看问题。"),r("strong",[e._v("第一问：Foo.getName()")]),e._v(" 他问的是Foo这个函数上创建的 getName 方法，这个so easy，当然是alert(2)了。"),r("strong",[e._v("第二问：getName()")]),e._v("。他问的是 window 上的 getName 方法，经过我们上述处理，很容易看出来，alert(4)。"),r("strong",[e._v("第三问：Foo().getName()")]),e._v("。这个稍微有点可以说道说道的了")]),e._v(" "),r("h3",[e._v("作用域")]),e._v(" "),r("p",[e._v("首先他执行的是一个叫做 Foo 的函数，我们来看这个函数体内部。这个函数体内部就做了两件事：1. 他将一个 alert(1) 的 function 赋值给了 getName ，2. return 了一个 this\r\n    ")]),e._v(" "),r("p",[r("span",{staticClass:"warnning"},[e._v("WAIT，")]),e._v("当我们仔细看的时候，发现这个getName前面竟然没有关键字 var ！！这就麻烦了，当他没有用关键字 var 的时候，我们就应该知道，这个 getName 不应该是个局部变量，我们应该沿着他的作用域去找，找找看哪里有 getName 被声明了。好吧，这个同样也很简单，当然是 window 中咯，window 中刚好有个 getName 被赋值为 alert(4) 函数。那么当 Foo() 中执行 getName = function() {alert(1)} 的时候，很显然 window 中的 getName 又悲催的被替换了。接下去就很好理解了，Foo return 了一个 this， 这个 this 很显然是指向 window 的。别问我为什么，因为 Foo() 不就是 window.Foo() 吗？所以后面的 getName() 不就等于 window.getName() 了嘛，而window.getName() 不刚好被他第一句话给改掉了嘛，所以变成了 alert(1)")]),e._v(" "),r("p",[e._v("好了经过第三问这么一搞，我们的题目又改了")]),e._v(" "),r("pre",[e._v("\r\n        function Foo() {\r\n            getName = function() {\r\n                alert(1)\r\n            }\r\n            return this\r\n        }\r\n        Foo.getName = function() {\r\n            alert(2)\r\n        }\r\n        Foo.prototype.getName = function() {\r\n            alert(3)\r\n        }\r\n        var getName;\r\n        getName = function() {\r\n            alert(1)\r\n        }\r\n    ")]),e._v(" "),r("p",[r("strong",[e._v("第四问: getName()")]),e._v(" 这就不用再说了 alert(1) 。")]),e._v(" "),r("p",[r("strong",[e._v("第五问:new Foo.getName()")]),e._v(" 其实是将Foo.getName作为构造函数执行了, 所以 alert(2) ")]),e._v(" "),r("p",[r("strong",[e._v("第六问：new Foo().getName()")]),e._v(" 当时我看着这玩意儿有点懵逼了，这到底该怎么执行呢？他其实是将 Foo() 作为一个构造函数 new 出来之后再调用 getName 的方法。")]),e._v(" "),r("p",[e._v("即使我们搞清楚了怎么执行，那也还有一个问题，就是说我们一般碰到的构造函数都是不带返回值的，那像 Foo() 这样的带返回值的构造函数又该怎么样呢？这时候，如果返回值为非引用类型的，那么跟没有返回值是一样的，如果为引用类型的，那么返回这个引用类型。这里的 Foo() 返回的是 this 。 this 在构造函数中指向的是当前实例化对象（其实在这里 Foo() return this 和不 return this 效果是一样的），然后在调用当前实例化对象的 getName() 。所以输出 3。")]),e._v(" "),r("p",[r("strong",[e._v("第七问：new new Foo().getName()")]),e._v(" 首先他将 Foo作为一个构造函数，然后返回了一个实例化对象，实例化对象上找到 getName 方法后， 继续对 getName 方法进行 new 操作。所以输出 3。")])])}]}}});
//# sourceMappingURL=13.ac44f6e71ea8216db94e.js.map