{"version":3,"sources":["webpack:///static/js/13.ac44f6e71ea8216db94e.js","webpack:///./src/views/articles/interview2.vue","webpack:///./src/views/articles/interview2.vue?7d4a"],"names":["webpackJsonp","33","module","exports","__webpack_require__","Component","76","render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","staticClass","_v"],"mappings":"AAAAA,cAAc,KAERC,GACA,SAAUC,EAAQC,EAASC,GCHjC,GAAAC,GAAAD,EAAA,GAEA,KAEAA,EAAA,IAEA,KAEA,KAGAF,GAAAC,QAAAE,EAAAF,SDUMG,GACA,SAAUJ,EAAQC,GEtBxBD,EAAAC,SAAgBI,OAAA,WAAmB,GAAAC,GAAAC,KAAaC,EAAAF,EAAAG,cAA0BH,GAAAI,MAAAC,EAC1E,OAAAL,GAAAM,GAAA,IACCC,iBAAA,WAA+B,GAAAP,GAAAC,KAAaC,EAAAF,EAAAG,eAA0BE,EAAAL,EAAAI,MAAAC,IAAAH,CACvE,OAAAG,GAAA,OAAAA,EAAA,OACAG,YAAA,UACGR,EAAAS,GAAA,aAAAT,EAAAS,GAAA,KAAAJ,EAAA,OACHG,YAAA,QACGR,EAAAS,GAAA,gBAAAT,EAAAS,GAAA,KAAAJ,EAAA,WAAAL,EAAAS,GAAA,+CAAAT,EAAAS,GAAA,KAAAJ,EAAA,MAAAL,EAAAS,GAAA,QAAAT,EAAAS,GAAA,KAAAJ,EAAA,OAAAL,EAAAS,GAAA,2sBAA4nBT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,qBAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,mNAAAT,EAAAS,GAAA,KAAAJ,EAAA,MAAAL,EAAAS,GAAA,YAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,qCAAAT,EAAAS,GAAA,KAAAJ,EAAA,OAAAL,EAAAS,GAAA,sFAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,eAAAT,EAAAS,GAAA,KAAAJ,EAAA,OAAAL,EAAAS,GAAA,0EAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,iCAAAT,EAAAS,GAAA,KAAAJ,EAAA,OAAAL,EAAAS,GAAA,2EAAohCT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,kJAAAT,EAAAS,GAAA,KAAAJ,EAAA,OAAAL,EAAAS,GAAA,+IAA0YT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,yCAAAT,EAAAS,GAAA,KAAAJ,EAAA,OAAAL,EAAAS,GAAA,oaAA2gBT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,aAAAJ,EAAA,UAAAL,EAAAS,GAAA,uBAAAT,EAAAS,GAAA,uDAAAJ,EAAA,UAAAL,EAAAS,GAAA,mBAAAT,EAAAS,GAAA,wDAAAJ,EAAA,UAAAL,EAAAS,GAAA,yBAAAT,EAAAS,GAAA,qBAAAT,EAAAS,GAAA,KAAAJ,EAAA,MAAAL,EAAAS,GAAA,SAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,wHAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAA,EAAA,QACxiFG,YAAA,aACGR,EAAAS,GAAA,WAAAT,EAAAS,GAAA,ocAAsQT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,0BAAAT,EAAAS,GAAA,KAAAJ,EAAA,OAAAL,EAAAS,GAAA,oaAA0sBT,EAAAS,GAAA,KAAAJ,EAAA,KAAAA,EAAA,UAAAL,EAAAS,GAAA,oBAAAT,EAAAS,GAAA,yBAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAA,EAAA,UAAAL,EAAAS,GAAA,2BAAAT,EAAAS,GAAA,6CAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAA,EAAA,UAAAL,EAAAS,GAAA,6BAAAT,EAAAS,GAAA,6EAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAL,EAAAS,GAAA,6PAAAT,EAAAS,GAAA,KAAAJ,EAAA,KAAAA,EAAA,UAAAL,EAAAS,GAAA,iCAAAT,EAAAS,GAAA","file":"static/js/13.ac44f6e71ea8216db94e.js","sourcesContent":["webpackJsonp([13],{\n\n/***/ 33:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  null,\n  /* template */\n  __webpack_require__(76),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 76:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('div', {\n    staticClass: \"title\"\n  }, [_vm._v(\"前端面试(二)\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"tag\"\n  }, [_vm._v(\"javascript\")]), _vm._v(\" \"), _c('summary', [_vm._v(\"之前面试看到这么一个题目，当时脑子没转过弯来，后来在网上参考了一些东西，然后写下来\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"题目\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        function Foo() {\\r\\n            getName = function() {\\r\\n                alert(1)\\r\\n            }\\r\\n            return this\\r\\n        }\\r\\n        Foo.getName = function() {\\r\\n            alert(2)\\r\\n        }\\r\\n        Foo.prototype.getName = function() {\\r\\n            alert(3)\\r\\n        }\\r\\n        var getName = function() {\\r\\n            alert(4)\\r\\n        }\\r\\n        function getName() {\\r\\n            alert(5)\\r\\n        }\\r\\n        // 然后问一下输出什么\\r\\n        Foo.getName()\\r\\n        getName()\\r\\n        Foo().getName()\\r\\n        getName()\\r\\n        new Foo.getName()\\r\\n        new Foo().getName()\\r\\n        new new Foo().getName()\\r\\n        // 答案是: 2 4 1 1 2 3 3\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"为什么是这样呢？我们一个个来看\")]), _vm._v(\" \"), _c('p', [_vm._v(\"首先，他用函数表达式定义了一个Foo的函数，函数在刚被定义的时候是不执行的；之后为Foo创建了一个getName的方法；接着在Foo的原型上创建了一个getName的方法；最后，在全局（window）中分别用函数表达式和函数声明式创建了两个getName的函数，题目看到这里首先就出现了一个问题：在window下明显不可能同时出现两个getName函数，那势必有一个函数是会被覆盖掉的，问题是哪一个会被覆盖呢？\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"变量声明提前\")]), _vm._v(\" \"), _c('p', [_vm._v(\"我们都知道js存在一个声明提前的问题，比如这样的一个简单问题：\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        console.log(x)// 报错Uncaught ReferenceError: x is not defined\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"但是这样又不一样了\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        console.log(x) // undefined\\r\\n        var x = 1\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"他会输出undefined。因为上面的方法相当于这样:\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        var x;\\r\\n        console.log(x)\\r\\n        x = 1\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"这就是声明提前。从这里可以看出，用关键字var声明的变量会提前，但是其不会赋值，也就是说他会把声明提到前面，而把赋值留在原地。但是，你用函数表达式声明一个函数的时候，他也会提前，但是他的提前就不是这么提前了，他会将整个函数体都提到前面来，所以上面最后两个getName相当于这样：\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        var getName; // 将变量提前\\r\\n        function getName() {alert(5)} // 将整个函数体提前\\r\\n        getName = function() {alert(4)}\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"所以，最后两个只会保留alert(4)函数。这样一理的话原题目就变成了\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        function Foo() {\\r\\n            getName = function() {\\r\\n                alert(1)\\r\\n            }\\r\\n            return this\\r\\n        }\\r\\n        Foo.getName = function() {\\r\\n            alert(2)\\r\\n        }\\r\\n        Foo.prototype.getName = function() {\\r\\n            alert(3)\\r\\n        }\\r\\n        var getName;\\r\\n        getName = function() {\\r\\n            alert(4)\\r\\n        }\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"然后我们再看问题。\"), _c('strong', [_vm._v(\"第一问：Foo.getName()\")]), _vm._v(\" 他问的是Foo这个函数上创建的 getName 方法，这个so easy，当然是alert(2)了。\"), _c('strong', [_vm._v(\"第二问：getName()\")]), _vm._v(\"。他问的是 window 上的 getName 方法，经过我们上述处理，很容易看出来，alert(4)。\"), _c('strong', [_vm._v(\"第三问：Foo().getName()\")]), _vm._v(\"。这个稍微有点可以说道说道的了\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"作用域\")]), _vm._v(\" \"), _c('p', [_vm._v(\"首先他执行的是一个叫做 Foo 的函数，我们来看这个函数体内部。这个函数体内部就做了两件事：1. 他将一个 alert(1) 的 function 赋值给了 getName ，2. return 了一个 this\\r\\n    \")]), _vm._v(\" \"), _c('p', [_c('span', {\n    staticClass: \"warnning\"\n  }, [_vm._v(\"WAIT，\")]), _vm._v(\"当我们仔细看的时候，发现这个getName前面竟然没有关键字 var ！！这就麻烦了，当他没有用关键字 var 的时候，我们就应该知道，这个 getName 不应该是个局部变量，我们应该沿着他的作用域去找，找找看哪里有 getName 被声明了。好吧，这个同样也很简单，当然是 window 中咯，window 中刚好有个 getName 被赋值为 alert(4) 函数。那么当 Foo() 中执行 getName = function() {alert(1)} 的时候，很显然 window 中的 getName 又悲催的被替换了。接下去就很好理解了，Foo return 了一个 this， 这个 this 很显然是指向 window 的。别问我为什么，因为 Foo() 不就是 window.Foo() 吗？所以后面的 getName() 不就等于 window.getName() 了嘛，而window.getName() 不刚好被他第一句话给改掉了嘛，所以变成了 alert(1)\")]), _vm._v(\" \"), _c('p', [_vm._v(\"好了经过第三问这么一搞，我们的题目又改了\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        function Foo() {\\r\\n            getName = function() {\\r\\n                alert(1)\\r\\n            }\\r\\n            return this\\r\\n        }\\r\\n        Foo.getName = function() {\\r\\n            alert(2)\\r\\n        }\\r\\n        Foo.prototype.getName = function() {\\r\\n            alert(3)\\r\\n        }\\r\\n        var getName;\\r\\n        getName = function() {\\r\\n            alert(1)\\r\\n        }\\r\\n    \")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第四问: getName()\")]), _vm._v(\" 这就不用再说了 alert(1) 。\")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第五问:new Foo.getName()\")]), _vm._v(\" 其实是将Foo.getName作为构造函数执行了, 所以 alert(2) \")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第六问：new Foo().getName()\")]), _vm._v(\" 当时我看着这玩意儿有点懵逼了，这到底该怎么执行呢？他其实是将 Foo() 作为一个构造函数 new 出来之后再调用 getName 的方法。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"即使我们搞清楚了怎么执行，那也还有一个问题，就是说我们一般碰到的构造函数都是不带返回值的，那像 Foo() 这样的带返回值的构造函数又该怎么样呢？这时候，如果返回值为非引用类型的，那么跟没有返回值是一样的，如果为引用类型的，那么返回这个引用类型。这里的 Foo() 返回的是 this 。 this 在构造函数中指向的是当前实例化对象（其实在这里 Foo() return this 和不 return this 效果是一样的），然后在调用当前实例化对象的 getName() 。所以输出 3。\")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第七问：new new Foo().getName()\")]), _vm._v(\" 首先他将 Foo作为一个构造函数，然后返回了一个实例化对象，实例化对象上找到 getName 方法后， 继续对 getName 方法进行 new 操作。所以输出 3。\")])])\n}]}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/13.ac44f6e71ea8216db94e.js","var Component = require(\"!../../../node_modules/_vue-loader@11.3.4@vue-loader/lib/component-normalizer\")(\n  /* script */\n  null,\n  /* template */\n  require(\"!!../../../node_modules/_vue-loader@11.3.4@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-0efd0090\\\"}!../../../node_modules/_vue-loader@11.3.4@vue-loader/lib/selector?type=template&index=0!./interview2.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/articles/interview2.vue\n// module id = 33\n// module chunks = 13","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('div', {\n    staticClass: \"title\"\n  }, [_vm._v(\"前端面试(二)\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"tag\"\n  }, [_vm._v(\"javascript\")]), _vm._v(\" \"), _c('summary', [_vm._v(\"之前面试看到这么一个题目，当时脑子没转过弯来，后来在网上参考了一些东西，然后写下来\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"题目\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        function Foo() {\\r\\n            getName = function() {\\r\\n                alert(1)\\r\\n            }\\r\\n            return this\\r\\n        }\\r\\n        Foo.getName = function() {\\r\\n            alert(2)\\r\\n        }\\r\\n        Foo.prototype.getName = function() {\\r\\n            alert(3)\\r\\n        }\\r\\n        var getName = function() {\\r\\n            alert(4)\\r\\n        }\\r\\n        function getName() {\\r\\n            alert(5)\\r\\n        }\\r\\n        // 然后问一下输出什么\\r\\n        Foo.getName()\\r\\n        getName()\\r\\n        Foo().getName()\\r\\n        getName()\\r\\n        new Foo.getName()\\r\\n        new Foo().getName()\\r\\n        new new Foo().getName()\\r\\n        // 答案是: 2 4 1 1 2 3 3\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"为什么是这样呢？我们一个个来看\")]), _vm._v(\" \"), _c('p', [_vm._v(\"首先，他用函数表达式定义了一个Foo的函数，函数在刚被定义的时候是不执行的；之后为Foo创建了一个getName的方法；接着在Foo的原型上创建了一个getName的方法；最后，在全局（window）中分别用函数表达式和函数声明式创建了两个getName的函数，题目看到这里首先就出现了一个问题：在window下明显不可能同时出现两个getName函数，那势必有一个函数是会被覆盖掉的，问题是哪一个会被覆盖呢？\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"变量声明提前\")]), _vm._v(\" \"), _c('p', [_vm._v(\"我们都知道js存在一个声明提前的问题，比如这样的一个简单问题：\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        console.log(x)// 报错Uncaught ReferenceError: x is not defined\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"但是这样又不一样了\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        console.log(x) // undefined\\r\\n        var x = 1\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"他会输出undefined。因为上面的方法相当于这样:\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        var x;\\r\\n        console.log(x)\\r\\n        x = 1\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"这就是声明提前。从这里可以看出，用关键字var声明的变量会提前，但是其不会赋值，也就是说他会把声明提到前面，而把赋值留在原地。但是，你用函数表达式声明一个函数的时候，他也会提前，但是他的提前就不是这么提前了，他会将整个函数体都提到前面来，所以上面最后两个getName相当于这样：\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        var getName; // 将变量提前\\r\\n        function getName() {alert(5)} // 将整个函数体提前\\r\\n        getName = function() {alert(4)}\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"所以，最后两个只会保留alert(4)函数。这样一理的话原题目就变成了\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        function Foo() {\\r\\n            getName = function() {\\r\\n                alert(1)\\r\\n            }\\r\\n            return this\\r\\n        }\\r\\n        Foo.getName = function() {\\r\\n            alert(2)\\r\\n        }\\r\\n        Foo.prototype.getName = function() {\\r\\n            alert(3)\\r\\n        }\\r\\n        var getName;\\r\\n        getName = function() {\\r\\n            alert(4)\\r\\n        }\\r\\n    \")]), _vm._v(\" \"), _c('p', [_vm._v(\"然后我们再看问题。\"), _c('strong', [_vm._v(\"第一问：Foo.getName()\")]), _vm._v(\" 他问的是Foo这个函数上创建的 getName 方法，这个so easy，当然是alert(2)了。\"), _c('strong', [_vm._v(\"第二问：getName()\")]), _vm._v(\"。他问的是 window 上的 getName 方法，经过我们上述处理，很容易看出来，alert(4)。\"), _c('strong', [_vm._v(\"第三问：Foo().getName()\")]), _vm._v(\"。这个稍微有点可以说道说道的了\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"作用域\")]), _vm._v(\" \"), _c('p', [_vm._v(\"首先他执行的是一个叫做 Foo 的函数，我们来看这个函数体内部。这个函数体内部就做了两件事：1. 他将一个 alert(1) 的 function 赋值给了 getName ，2. return 了一个 this\\r\\n    \")]), _vm._v(\" \"), _c('p', [_c('span', {\n    staticClass: \"warnning\"\n  }, [_vm._v(\"WAIT，\")]), _vm._v(\"当我们仔细看的时候，发现这个getName前面竟然没有关键字 var ！！这就麻烦了，当他没有用关键字 var 的时候，我们就应该知道，这个 getName 不应该是个局部变量，我们应该沿着他的作用域去找，找找看哪里有 getName 被声明了。好吧，这个同样也很简单，当然是 window 中咯，window 中刚好有个 getName 被赋值为 alert(4) 函数。那么当 Foo() 中执行 getName = function() {alert(1)} 的时候，很显然 window 中的 getName 又悲催的被替换了。接下去就很好理解了，Foo return 了一个 this， 这个 this 很显然是指向 window 的。别问我为什么，因为 Foo() 不就是 window.Foo() 吗？所以后面的 getName() 不就等于 window.getName() 了嘛，而window.getName() 不刚好被他第一句话给改掉了嘛，所以变成了 alert(1)\")]), _vm._v(\" \"), _c('p', [_vm._v(\"好了经过第三问这么一搞，我们的题目又改了\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"\\r\\n        function Foo() {\\r\\n            getName = function() {\\r\\n                alert(1)\\r\\n            }\\r\\n            return this\\r\\n        }\\r\\n        Foo.getName = function() {\\r\\n            alert(2)\\r\\n        }\\r\\n        Foo.prototype.getName = function() {\\r\\n            alert(3)\\r\\n        }\\r\\n        var getName;\\r\\n        getName = function() {\\r\\n            alert(1)\\r\\n        }\\r\\n    \")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第四问: getName()\")]), _vm._v(\" 这就不用再说了 alert(1) 。\")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第五问:new Foo.getName()\")]), _vm._v(\" 其实是将Foo.getName作为构造函数执行了, 所以 alert(2) \")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第六问：new Foo().getName()\")]), _vm._v(\" 当时我看着这玩意儿有点懵逼了，这到底该怎么执行呢？他其实是将 Foo() 作为一个构造函数 new 出来之后再调用 getName 的方法。\")]), _vm._v(\" \"), _c('p', [_vm._v(\"即使我们搞清楚了怎么执行，那也还有一个问题，就是说我们一般碰到的构造函数都是不带返回值的，那像 Foo() 这样的带返回值的构造函数又该怎么样呢？这时候，如果返回值为非引用类型的，那么跟没有返回值是一样的，如果为引用类型的，那么返回这个引用类型。这里的 Foo() 返回的是 this 。 this 在构造函数中指向的是当前实例化对象（其实在这里 Foo() return this 和不 return this 效果是一样的），然后在调用当前实例化对象的 getName() 。所以输出 3。\")]), _vm._v(\" \"), _c('p', [_c('strong', [_vm._v(\"第七问：new new Foo().getName()\")]), _vm._v(\" 首先他将 Foo作为一个构造函数，然后返回了一个实例化对象，实例化对象上找到 getName 方法后， 继续对 getName 方法进行 new 操作。所以输出 3。\")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_vue-loader@11.3.4@vue-loader/lib/template-compiler?{\"id\":\"data-v-0efd0090\"}!./~/_vue-loader@11.3.4@vue-loader/lib/selector.js?type=template&index=0!./src/views/articles/interview2.vue\n// module id = 76\n// module chunks = 13"],"sourceRoot":""}