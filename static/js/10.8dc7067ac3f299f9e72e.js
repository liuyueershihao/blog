webpackJsonp([10],{37:function(n,r,e){var i=e(0)(null,e(82),null,null);n.exports=i.exports},82:function(n,r){n.exports={render:function(){var n=this,r=n.$createElement;n._self._c;return n._m(0)},staticRenderFns:[function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("div",[e("div",{staticClass:"title"},[n._v("\r\n        python入门（二）\r\n    ")]),n._v(" "),e("div",{staticClass:"tag"},[n._v("\r\n        python\r\n    ")]),n._v(" "),e("summary",[n._v("Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。")]),n._v(" "),e("h3",[n._v("1. 列表的更多特性")]),n._v(" "),e("pre",[n._v("\r\n        list.append(x) #列表末尾添加元素\r\n        等价于\r\n        list = list + [x]\r\n\r\n        list.extend(L) #列表末尾添加列表\r\n        等价于\r\n        list = list + L\r\n\r\n        list.insert(i, x) #向指定位置插入一个元素\r\n        等价于\r\n        list = list[0:i] + [x] + list[i:]\r\n\r\n        list.remove(x) #在列表中删除第一个为x的元素,如果没有这样的x元素,则报错\r\n        等价于\r\n        for index in range(len(list)):\r\n          if list[index] == x:\r\n            list = list[0:index] + list[index-1:]\r\n            print(list)\r\n            break #为了防止越界\r\n          else:\r\n            if index == len(list) - 1 and list[len(list) - 1] != x\r\n              print('error')\r\n\r\n        list.pop(i) #删除列表中指定位置的元素,如果不指定i则删除最后一个元素,并将该元素返回\r\n        等价于\r\n        list = list[:-1]\r\n\r\n        list.clear() #清空列表\r\n        等价于\r\n        list = []\r\n\r\n        list.index(x) #返回列表中第一个x元素所在的位置,如果没有则报错\r\n        for index in range(len(list)):\r\n          if list[index] == x:\r\n            print(index)\r\n            break #减少循环次数,返回第一个index\r\n\r\n        list.count(x) #返回列表中x出现的次数,没有则返回0\r\n        等价于\r\n        i = 0\r\n        for l in list\r\n          if l == x:\r\n            i = i + 1\r\n        print(i)\r\n\r\n        list.reverse() #列表中的元素反转\r\n        listCopy = []\r\n        for index in range(len(list)):\r\n          listCopy = listCopy + [list[-index-1]]\r\n        print(listCopy)\r\n\r\n        list.sort() #列表排序(升序),当传入参数reverse = True时为降序,还有sorted(),不是很懂,留待以后研究\r\n\r\n        list.copy() #返回一个浅copy\r\n        等价于\r\n        list[:]\r\n    ")]),n._v(" "),e("h3",[n._v("2. 列表作为栈使用(先进后出)")]),n._v(" "),e("pre",[n._v("\r\n        list.append()\r\n        list.pop()\r\n    ")]),n._v(" "),e("h3",[n._v("3. 列表作为队列使用(先进先出)")]),n._v(" "),e("pre",[n._v("\r\n        >>>from collections import deque\r\n        >>> queue = deque([\"Eric\", \"John\", \"Michael\"])\r\n        >>> queue.append(\"Terry\")           # Terry arrives\r\n        >>> queue.append(\"Graham\")          # Graham arrives\r\n        >>> queue.popleft()                 # The first to arrive now leaves\r\n        'Eric'\r\n        >>> queue.popleft()                 # The second to arrive now leaves\r\n        'John'\r\n        >>> queue                           # Remaining queue in order of arrival\r\n        deque(['Michael', 'Terry', 'Graham'])\r\n    ")]),n._v(" "),e("p",[n._v("直接用了官网的例子,他用了一个collections库中的deque方法.对这个库我还没接触过,所以对他不熟,而且,他也只用了poplef()方法,即只从头移除,没从头进入,但是我觉得python的切片真的很好用,这个用python的切片也可以做到,但是具体从性能啊其他方面暂时不予考虑,只考虑效果")]),n._v(" "),e("pre",[n._v("\r\n        list = [1,2,3,4,5]\r\n        list = [0] + list #在头部加入一个0\r\n        list = list[1:] #删除头部\r\n    ")]),n._v(" "),e("h3",[n._v("4. del语句")]),n._v(" "),e("pre",[n._v("\r\n        del list[index] #删除单个元素\r\n        del list[index1:index2] #删除多个元素\r\n        del list[:] #清空list\r\n        del list #删除整个变量\r\n    ")]),n._v(" "),e("p",[n._v("del与pop区别：两者同时修改远列表,但del直接删除无返回值,pop有返回值")])])}]}}});
//# sourceMappingURL=10.8dc7067ac3f299f9e72e.js.map